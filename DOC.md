# CI/CD 探索

## CI

在多人开发中我们总是要规范提交代码，并写一个 ** commit message **，大伙都能读懂并且标注清楚这个commit message 有包含哪些内容。

## commit message格式

```
<type>(<scope>): <subject>
```
**type(必须)**
用于说明git commit的类别，只允许使用下面的标识。

- feat：新功能（feature）。
- fix/to：修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。
  - fix：产生diff并自动修复此问题。适合于一次提交直接修复问题
  - to：只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix
- docs：文档（documentation）。
- style：格式（不影响代码运行的变动）。
- refactor：重构（即不是新增功能，也不是修改bug的代码变动）。
- perf：优化相关，比如提升性能、体验。
- test：增加测试。
- chore：构建过程或辅助工具的变动。
- revert：回滚到上一个版本。
- merge：代码合并。
- sync：同步主线或分支的Bug。

**scope(可选)**
scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。

**subject(必须)**
subject是commit目的的简短描述，不超过50个字符。

但是多人开发下团队需要约定要怎么填，但是每次的手动输入可能会有拼错或者繁杂，然后每次本地开发完还要去创建 mr 去合并到测试分支&生产分支等一系列繁琐操作，那么开发一个 cli 来帮助团队解决这些问题。

比如像项目里面的 **to-self** 就能将本地开发完后的代码直接推送到远程的同名分支，或者 **to-test** 直接推送到测试分支并且同时推送至远程同名分支，而**to-main** 则是将当前分支推送至远程同名分支并打印一个用于手动创建 MR/PR 的网页地址。

#### to-self 介绍

代码帮你执行了git add -A，这时候你只需要选择提供的 type，scope，然后填写你的 subject，代码会自动生成 commit message 并把你的代码推送到远程分支，如果你的代码已经有你的手动 commit，那么就会直接推送

#### to-test 介绍

先是执行 to-self 的流程，然后 checkout 到测试分支把远程的 to-self 同名分支变更合并到本地的测试分支，合并完后就推送到远程的测试分支，当然这一切都是自动化的，你所需做的仅仅是输入 subject

#### to-main 介绍

先是执行 to-self 的流程，然后打印一个用于手动创建 MR/PR 的网页地址，因为生产分支是必须受保护的，不能乱合代码上去

## CD
既然 CI 流程已经自动化了，那么直接 CD 也聚合到 cli 里面实现自动化复用到多个项目岂不美哉，但是每个团队的部署需求都不一样的，所以 cli 就提供一个模版，后续可以根据需求去改动 CD 的具体逻辑就能实现 CI/CD 自动化

就比如改动一下 core/deploy/toDeploy.ts 的逻辑实现自身需求的部署逻辑，然后在对应的项目的部署文件改动部署命令

如果是新项目的话还能直接执行 **to-init** 命令生成部署模版文件，当然要改部署模版文件就可以改动 core/init/xx.deploy.template.ts 模版文件

## 小结
这只是我探索 CI/CD 的一个思路，应该还有其他的方式，找适合自身的去实现就好了